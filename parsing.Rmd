---
title: "Getting data into R"
output: html_document
bibliography: "bibtexlib.bib"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

## Typical format for microbiome data

Most pipelines for processing high-throughput amplicon data, such as mothur, QIIME, and dada2, result in a matrix of read counts.
One dimension of this matrix consists of OTUs, phylotypes, or unique sequences (all ways to "bin" similar read sequences).
The other dimension consists of samples.
Different tools will expect/output different orientations of the matrix, but, in general, columns are samples and rows are OTUs/phylotypes:

```{r echo=FALSE}
make_ex_mat <- function(n_otu = 6, n_sample = 6,
                        otu_names = paste0("otu_", seq_len(n_otu)),
                        sam_names = paste0("sample_", seq_len(n_sample))) {
  set.seed(1)
  my_mat <- matrix(nrow = n_sample, ncol = n_otu, dimnames = list(otu_names, sam_names))
  my_mat[] <- sample(c(rep(0, 100), 1:100), n_otu * n_sample)
  return(my_mat)
}
print(make_ex_mat())
```

Each sample and OTU will have an unique ID.
Sometimes people will construct the sample ID so that it contains the treatment and replicate number:

```{r, echo=FALSE}
print(make_ex_mat(n_otu = 6, n_sample = 6,
                  otu_names = paste0("otu_", seq_len(6)),
                  sam_names = c(paste0("treated_", seq_len(3)), paste0("control_", seq_len(3)))))
```


This helps quickly identifying samples during an analysis, but it is usually better to store sample information in another table, with sample IDs in rows and sample characteristics in columns:

```{r, echo=FALSE}
print(data.frame(sample_id = paste0("sample_", seq_len(6)),
                 treated = c(rep(TRUE, 3), rep(FALSE, 3))))
```

This makes it easy to add lots of additional sample data columns that can be used to subset the data. 

## Importing data into R

Importing data into R can be quite easy if the data is formatted well, but can be a very frustrating experience otherwise.
In this case, well formatted data consists of .csv (comma-separated value) or .tsv (tab-separated value) files, each with a single table and no additional comments or formatting.
Either of these formats might also have a .txt extension (the extension does not really matter; its for humans, not computers).
For more information on correct data formatting, see the [data formating section](http://grunwaldlab.github.io/Reproducible-science-in-R/03--Data_formatting.html) of our [guide for reporducible research](http://grunwaldlab.github.io/Reproducible-science-in-R/index.html).
You should always import the raw output data whenever possible and avoid any "manual" (i.e. non-scripted) modification of the data, especially in programs like Excel, which are known to mangle data from time to time (@zeeberg2004mistaken).

Throughout this workshop, we will be using data from @wagner2016host, a study on the effects of plant age, genotype, and environment on the bacterial microbiome of [*Boechera stricta*](https://en.wikipedia.org/wiki/Boechera_stricta), a perennial herb in the mustard family.
@wagner2016host released their raw data with the article and it is available [here](http://datadryad.org/resource/doi:10.5061/dryad.g60r3) on [dryad](http://datadryad.org/).
This is a great example of how to share your raw data.

There are many functions commonly used to read tabular data, including the traditional ones like `read.table` and `read.csv`, but we will be using functions from the new [`readr` package](http://readr.tidyverse.org/articles/readr.html), which returns ["tibbles"](http://r4ds.had.co.nz/tibbles.html) instead of `data.frame`s (A "table" in R).
Tibbles are a type of `data.frame` with some fancier printing and more consistent behavior.
Lets read in the raw OTU table first:

```{r message=FALSE}
library(readr) # Loads the readr package so we can use `read_tsv`
otu_data <- read_tsv("data/otuTable97.txt")
print(otu_data) # You can also simply enter `otu_data` to print it
```

This is a big data set, with `r nrow(otu_data)` rows (OTUs) and `r ncol(otu_data)` columns (`r ncol(otu_data) - 1` samples and an OTU ID).
If your laptop cannot load this file, don't worry, we will provide a subset later for the rest of the workshop. 

In this data set, the taxonomic classification for each OTU is in a different file.
This information could have been included as additional columns in the OTU table and often is in other data sets.

```{r message=FALSE}
tax_data <- read_tsv("data/taxAssignments97.txt")
print(tax_data) # You can also simply enter `tax_data` to print it
```

Although these data are very well-formatted compared to most, it is not perfect.
The "OTU ID" column contains a space in the name (hence the back ticks), which makes it a bit more annoying to work with in R.
More importantly, the OTU IDs in the taxonomy table are prefixed with "OTU_" and those in the OTU table are not, so we have to remove that prefix to make the two match up:

```{r}
tax_data$`OTU ID` <- sub(tax_data$`OTU ID`, # ` are needed because of the space
                         pattern = "OTU_", replacement = "")
print(tax_data) 
```

Although we could proceed with the analysis using separate OTU and taxonomy tables, lets combine them to simplify things.
Since the rows are in different order, we need to combine (aka "join") them based on their OTU ID.
We will use the [`dplyr` package](https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html) for this.

```{r message=FALSE}
library(dplyr) # Loads the dplyr package so we can use `left_join`
tax_data$`OTU ID` <- as.character(tax_data$`OTU ID`) # Must be same type for join to work
otu_data$OTU_ID <- as.character(otu_data$OTU_ID) # Must be same type for join to work
otu_data <- left_join(otu_data, tax_data,
                      by = c("OTU_ID" = "OTU ID")) # identifies cols with shared IDs
print(otu_data)
```

There are so many columns that all of them are not shown in the print out, but we can verify that they are there: 

```{r}
tail(colnames(otu_data), n = 10)
```

Next, lets load the sample data:

```{r message=FALSE}
sample_data <- read_tsv("data/sample_data.txt")
print(sample_data) # You can also simply enter `sample_data` to print it
```

Note how the number of sample columns in `otu_data` is equal to the number of rows in `sample_data` and the columns names of `otu_data` appear in the "SampleID" column.

## Converting to the `taxmap` format

Although our data is now in R, it is not in a format that is specialized for community abundance data; all R knows is that you have a few big tables. 
Different R packages for community (e.g. microbiome) analysis expect data in different formats or **classes**.
A class, in programming jargon, is a defined way to store data plus some functions designed to interact with that data.
When you format a specific data set in this way, we call it an **object** or an instance of the class.
Many packages implement their own classes and functions to convert data to their format, whereas some packages use the classes defined in other packages.
There are a few options for how to store an abundance matrix classified by a taxonomy in R (e.g. `phyloseq` objects), but we will be using classes defined in the `taxa` package here.
The goal of the `taxa` package is to provide an all-purpose standard way of manipulation any type of information assigned to a taxonomy.
`Taxa` provides a set of flexible parsers that should be able to read nearly any format, given the correct settings.

> Add link to taxa parsing guide once it is online

The taxonomic data we appended to the abundance matrix has the following form: 

```{r}
head(otu_data$taxonomy, 10)
```

Note that there are some odd aspects to the format that could make it challenging to parse:

* Some taxa have ranks (e.g. "k__Bacteria") and some dont (e.g. "Unassigned" and "Root"). 
* Some taxa have ranks, but no names (e.g. "f__").

If we just consider the ranks to be a part of the taxon name, then its pretty easy to parse:

```{r}
library(taxa)
obj <- parse_tax_data(otu_data,
                      class_cols = "taxonomy",
                      class_sep = ";")
print(obj)
```

This is the print out of a `taxmap` object.
The first line tells us that the OTUs are assigned to `r length(obj$taxon_names())` unique taxa and lists their IDs and names.
The second line describes how taxa relate to eachother in the tree.
Note how our original data are now inside this object: 

```{r}
print(obj$data$tax_data)
```

It now has a "taxon_id" column, which maps rows in the table to a taxa in the taxonomy.
This column is essential for the manipulation functions of `taxa`, like those shown later.

If we want to split out the rank information, we can use [regular expressions](https://en.wikipedia.org/wiki/Regular_expression) to specify which part of each taxon is a rank and which part is a name.
If are not familar with using regular expressions, this might be challenging to understand at first, but it is a very versitile skill to have, so it is worth learning 
One regular expression (aka "regex") that matches the pattern of taxon names is `^[a-z]{0,1}_{0,2}.*$`.
The `^` and `$` represent the start and end of the string.
The contents of the curly braces (e.g. `{0,1}`) indicate the number of time the preceding pattern can match. 
Likewise, the `*` means 0 or more matches.
The square brackets (e.g. `[a-z]`) specifiy a range of characters that can be matched. 
Likewsie the `.` means match any character.
For example the part of the regex `^[a-z]{0,1}` means "match a character `a` through `z` that occurs at the start of the string either zero or one times". 
We can add parentheses that specifiy which parts of the pattern go together; these are called "capture groups" in regex jargon.
For each capture group, the is a value given to the `class_key` option specifing what the group is (e.g. taxon name).
Putting this all together, we can parse the data like so:

```{r}
obj <- parse_tax_data(otu_data,
                      class_cols = "taxonomy",
                      class_sep = ";",
                      class_regex = "^([a-z]{0,1})_{0,2}(.*)$",
                      class_key = c("tax_rank" = "taxon_rank", "name" = "taxon_name"))
print(obj)
```

Note how the taxon names now do not have the rank information.
Instead, the rank information is in a seperate data set:

```{r}
obj$data$class_data
```

We can also see that there are some blank taxon names now.
These were the taxa that only had rank information (e.g. "f__").
These do not add any information and can be removed.



```{r, child="_sessioninfo.Rmd"}
save(obj, sample_data, file = "parsed_data.Rdata")
```

## References

