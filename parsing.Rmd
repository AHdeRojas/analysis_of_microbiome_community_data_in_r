---
title: "Getting data into R"
output: html_document
bibliography: "bibtexlib.bib"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

## Typical format for microbiome data

Most pipelines for processing high-throughput amplicon data, such as mothur, QIIME, and dada2, result in a matrix of read counts.
One dimension of this matrix is consists of OTUs, phylotypes, or unique sequences (all ways to "bin" similar read sequences).
The other dimension consists of samples.
Different tools will expect/output different orientations of the matrix, but, in general, columns are samples and rows are OTUs/phylotypes:

```{r echo=FALSE}
make_ex_mat <- function(n_otu = 6, n_sample = 6,
                        otu_names = paste0("otu_", seq_len(n_otu)),
                        sam_names = paste0("sample_", seq_len(n_sample))) {
  set.seed(1)
  my_mat <- matrix(nrow = n_sample, ncol = n_otu, dimnames = list(otu_names, sam_names))
  my_mat[] <- sample(c(rep(0, 100), 1:100), n_otu * n_sample)
  return(my_mat)
}
print(make_ex_mat())
```

Each sample and OTU will have an unique ID.
Sometimes people will construct the sample ID so that it contains the treatment and replicate number:

```{r, echo=FALSE}
print(make_ex_mat(n_otu = 6, n_sample = 6,
                  otu_names = paste0("otu_", seq_len(6)),
                  sam_names = c(paste0("treated_", seq_len(3)), paste0("control_", seq_len(3)))))
```


This helps quickly identifying samples during an analysis, but it is usually better to store sample information in another table, with sample IDs in rows and sample characteristics in columns:

```{r, echo=FALSE}
print(data.frame(sample_id = paste0("sample_", seq_len(6)),
                 treated = c(rep(TRUE, 3), rep(FALSE, 3))))
```

This makes it easy to add lots of additional sample data columns that can be used to subset the data. 

## Importing data into R

Importing data into R can be quite easy if the data is formatted well, but can be a very frustrating experience otherwise.
In summary, well formatted tabular data consists of .csv (comma-separated value) or .tsv (tab-separated value) files, each with a single table and no additional comments or formatting.
Either of these formats might also have a .txt extension instead.
For more information on correct data formatting, see the [data formating section](http://grunwaldlab.github.io/Reproducible-science-in-R/03--Data_formatting.html) of our [guide for reporducible research](http://grunwaldlab.github.io/Reproducible-science-in-R/index.html).
You should always import the raw output data whenever possible and avoid any "manual" (i.e. non-scripted) modification of the data, especially in programs like Excel, which are known to mangle data from time to time.

Throughout this workshop, we will be data from @wagner2016host, a study on the effects of plant age, genotype, and environment on the bacterial microbiome.
@wagner2016host released their raw data with the article and it is available [here](http://datadryad.org/resource/doi:10.5061/dryad.g60r3) on [dryad](http://datadryad.org/).
This is a great example of how to share your raw data.

There are many functions commonly used to read tabular data, including the traditional ones like `read.table` and `read.csv`, but we will be using functions from the new [`readr` package](http://readr.tidyverse.org/articles/readr.html), which returns ["tibbles"](http://r4ds.had.co.nz/tibbles.html) instead of `data.frame`s (A "table" in R).
Tibbles are a type of `data.frame` with some fancier printing and more consistent behavior.
Lets read in the raw OTU table first:

```{r message=FALSE}
library(readr) # Loads the readr package so we can use `read_tsv`
otu_data <- read_tsv("data/otuTable97.txt")
print(otu_data) # You can also simply enter `otu_data` to print it
```

This is a big data set, with `r nrow(otu_data)` rows (OTUs) and `r ncol(otu_data)` columns (`r ncol(otu_data) - 1` samples and an OTU ID).
If your laptop cannot load this file, don't worry, we will provide a subset later for the rest of the workshop. 

In this data set, the taxonomic classification for each OTU is in a different file.
This information could have been included as additional columns in the OTU table and often is in other data sets.

```{r}
tax_data <- read_tsv("data/taxAssignments97.txt")
print(tax_data) # You can also simply enter `tax_data` to print it
```

Although this data is very well-formatted, it is not perfect.
The "OTU ID" column contains a space in the name (hence the back ticks), which makes it a bit more annoying to work with in R.
More importantly, the OTU IDs in the taxonomy table are prefixed with "OTU_" and those in the OTU table are not, so we have to remove that prefix to make the two match up:

```{r}
tax_data$`OTU ID` <- sub(tax_data$`OTU ID`, # ` are needed because of the space
                         pattern = "OTU_", replacement = "")
tax_data$`OTU ID` <- as.numeric(tax_data$`OTU ID`) # The OTU ID in the OTU table is numeric
print(tax_data) 
```

Although we could proceed with the analysis using separate OTU and taxonomy tables, lets combine them to simplify things.
Since the rows are in different order, we need to combine (aka "join") them based on their OTU ID.
We will use the [`dplyr` package](https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html) for this.

```{r message=FALSE}
library(dplyr) # Loads the dplyr package so we can use `left_join`
otu_data <- left_join(otu_data, tax_data,
                      by = c("OTU_ID" = "OTU ID")) # identifies cols with shared IDs
print(otu_data)
```

There are so many columns that all of them are not shown in the print out, but we can verify that they are there: 

```{r}
tail(colnames(otu_data), n = 10)
```

Next, lets load the sample data:

```{r}
sample_data <- read_tsv("data/sample_data.txt")
print(sample_data) # You can also simply enter `sample_data` to print it
```

Note how the number of columns in `otu_data` (besides the OTU ID column) is equal to the number of rows in `sample_data` and the columns names of `sample_data` appear in the "OTU_ID" column.

## Converting to the `taxmap` format

Although our data is now in R it is not in a format that is specialized for community abundance data; all R knows is that you have a few big tables. 
Different R packages for community (e.g. microbiome) analysis expect data in different formats or **classes**.
A class, in programming jargon, is a defined way to store data.
When data is formatted this way, we call the data an **object** or an instance of the class.
Many packages implement their own classes and functions to convert data to their format, whereas some packages use the classes defined in other packages.
There are a few options for how to store an abundance matrix classified by a taxonomy in R (e.g. `phyloseq` objects), but we will be using classes defined in the `taxa` package here.
The goal of the `taxa` package is to provide an all-purpose standard way of manipulation any type of information assigned to a taxonomy.
`Taxa` provides a set of flexible parsers that should be able to read nearly any format, given the correct settings.

> Add link to taxa parsing guide once it is online

This format turns out to be quite easy to parse:

```{r}
library(taxa)
obj <- parse_tax_data(otu_data,
                      class_cols = c("Kingdom", "Phylum", "Class", "Order", "Family"))
print(obj)
```

This tells us that the OTUs are assigned to `r length(obj$taxon_names())` unique taxa.
This number included "coarse" taxa such as "Bacteria".

Note how our original data are now inside this object: 

```{r}
print(obj$data)
```

It also now has a "taxon_id" column, which maps to a particular taxon on the tree.
This column is essential for the manipulation functions of `taxa` we will cover later.

## Subsetting the data

Since this is such a large data set, we will subset it to make this workshop go faster and work on less powerful computers.

First, lets subset the samples to jsut those in main experiment described in @wagner2016host:

```{r}
sample_data <- subset(sample_data, Experiment == "ecotypes")
print(sample_data)
```


```{r}
obj %>% 
  filter_taxa(taxon_names == "Bacteria", subtaxa = TRUE) %>%
  filter_taxa(taxon_names != "NA")
```



## References

```{r, child="_sessioninfo.Rmd"}
```