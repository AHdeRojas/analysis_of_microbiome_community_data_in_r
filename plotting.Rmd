---
title: "Plotting taxonomic data"
output: html_document
bibliography: "bibtexlib.bib"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Throughout this workshop we will be making many familiar types of graphs using `ggplot2` and we will explain how they are made as we go.
In this section however, we will focus on using the `metacoder` package to plot information on a taxonomic tree using color and size to display data associated with taxa.

Taxonomic data can be difficult to graph since it is hierarchical.
For example, if you have abundance information for each taxon and want to graph it, what kind of plot do you use? 
Stacked bar charts and pie graphs are common choices, but these ignore the hierarchical nature of the data; typically only a single rank is graphed.
For example the graph below is from the publication that described the data set we are working with:

```{r echo=FALSE, out.width='100%'}
knitr::include_graphics('images/wagner_barchart.png')
```

Although this is a well constructed graph, its usefulness is limited by the nature of stacked barcharts.
The reliance on color to differentiate taxa means that the maximum number of taxa that can be effectively displayed is limited by the number of colors that can be distinguished.
This is typically around 10 or maybe 13 with careful selection, but definitely not more than 15.
This limitation is likely the reason @wagner2016host chose to show phylum-level abundances and grouped some phyla into a "Low abundance" category, even though there might be interesting pattern in finer ranks (e.g. genus or species).
Most publications either show only the most coarse ranks (e.g. phylum) or only the ~10 most abundant taxa when using stacked barcharts.
As an alternative/complement to stacked barcharts, we have developed what we call "heat trees" to display statistics associated with taxa (e.g. abundance) in a tree format.

## Load example data

If you are starting the workshop at this section, or had problems running code in a previous section, use the following code to load data used in this section.
If `obj` and `sample_data` are already in your environment from a previous section, you can ignore the following command.

```{r}
load("filtered_data.Rdata")
```


## Heat trees

The `metacoder` package implements "heat trees" to graph taxonomic data (@foster2017metacoder).
This visualization technique uses color and size of parts of a taxonomic tree to display numeric data associated with taxa.
Below is an example of a heat tree showing the number of OTUs in all taxa down to the class level:

```{r echo = FALSE}
library(metacoder)
obj %>% 
  filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  filter_taxa(taxon_ranks == "o", supertaxa = TRUE) %>% # subset to the class rank
  heat_tree(node_label = gsub(pattern = "\\[|\\]", replacement = "", taxon_names),
            node_size = n_obs,
            node_color = n_obs,
            node_color_axis_label = "OTU count",
            layout = "davidson-harel", initial_layout = "reingold-tilford")
```

This is a type of taxonomic tree where each **node** (the circles) is a taxon and the **edges** (lines) show hierarchical relationships between taxa.
For example, the large Proteobacteria phylum node contains the Alphaproteobacteria and Gammaproteobacteria classes.
This is a relatively small heat tree meant as a demonstration; much larger and more intricate ones would be more typical.
We are going to go through the process of creating a figure like this one in this section.
Although this might seem like complicated code to make this figure, code like this is typically the result of iterative small improvements started from a simple base.
We will imitate this process here for demonstration. 

## 

Lets start with simplest possible code.

```{r}
heat_tree(obj)
```

This is not too useful, but at least its easy!
Lets plot some data to make things more interesting.
A good start is to plot the number of OTUs (or other types of taxon observations) with both the color and size of nodes.
The taxon names are added as well

```{r}
heat_tree(obj,
          node_label = taxon_names,
          node_size = n_obs,
          node_color = n_obs)
```

The default layout is pretty cluttered with this amount of taxa (`r length(obj$taxa)`), so the labels are not readable with saving the graph as a PDF and zooming in.
With enough tweaking, we probably could make a tree with all `r length(obj$taxa)` taxa that looks good with a PDF viewer, but for this demonstration, we will try to make a plot that could be used in a publication with minimal zooming.
So, lets remove all taxa below the order rank to cut down the number of taxa displayed. 
We will also save the output as a PDF so we can take a closer look at the output.

```{r}
obj %>%
  filter_taxa(taxon_ranks == "o", supertaxa = TRUE) %>% # subset to the class rank
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            output_file = "plot_example_1.pdf")
```

If we zoom in on the output, we can see a lot of taxa with odd names like "Ellin329" and "BD7âˆ’3".
During analysis such taxa might be important to see, but for publication purposes, most can probably be removed from the plot to make it easier to understand.
We can filter those taxa out before plotting using a regular expression that only matches letters:

```{r}
obj %>%
  filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  filter_taxa(taxon_ranks == "o", supertaxa = TRUE) %>% # subset to the class rank
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            output_file = "plot_example_2.pdf")
```

Now we are getting to something more understandable.
Finally, lets play with the layout to see if we can find one that spaces things out better.
There are lots of layouts available, but only few produce reasonable results most of the time.
Some of the better ones for this use include:

* reingold-tilford (the default)
* davidson-harel
* fruchterman-reingold

You only need to use the first few letters of each name.
Lets look at these other two formats.
First, fruchterman-reingold:

```{r}
obj %>%
  filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  filter_taxa(taxon_ranks == "o", supertaxa = TRUE) %>% # subset to the class rank
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            layout = "fr",
            output_file = "plot_example_2.pdf")
```

These types of layouts have a random component to how they are made, so running the same code twice will produce different layouts.
Try running the above code again to see this.
We can force it to be the sample each time by setting the seed for the random number generator used by R, as is done in the next example.
This layout is not too bad, but does not make good use of space.
Lets try davidson-harel:

```{r}
set.seed(1) # you can choose any number. Each will produce a different layout
obj %>%
  filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  filter_taxa(taxon_ranks == "o", supertaxa = TRUE) %>% # subset to the class rank
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            layout = "da",
            output_file = "plot_example_2.pdf")
```

That's a bit better, but there is one more thing we can try.
The `heat_tree` functions allows you to set an "initial" layout that is used as the starting point for these other layouts.
We have found the combination of "reingold-tilford" and "davidson-harel" to be space-efficient for large plots.

```{r}
set.seed(2) # you can choose any number. Each will produce a different layout
obj %>%
  filter_taxa(grepl(pattern = "^[a-zA-Z]+$", taxon_names)) %>% # remove "odd" taxa
  filter_taxa(taxon_ranks == "o", supertaxa = TRUE) %>% # subset to the class rank
  heat_tree(node_label = taxon_names,
            node_size = n_obs,
            node_color = n_obs,
            initial_layout = "re", layout = "da",
            output_file = "plot_example_2.pdf")
```

Now we have replicated our original plot!
This kind of iterative refinement is the best way to make these complex plots, and complex plots in general.

```{r, child="_sessioninfo.Rmd"}
```

## References
